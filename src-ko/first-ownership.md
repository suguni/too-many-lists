# 소유권 101

이제 목록을 구성할 수 있게 되었으니 목록으로 무언가를 `할 수` 있으면 좋겠죠. 이를 위해 "일반" (정적이 아닌) 메서드를 사용합니다. 메서드는 선언된 타입이 없는 `self` 인자 때문에 Rust에서 함수의 특수한 경우입니다:

```rust ,ignore
fn foo(self, arg2: Type2) -> ReturnType {
    // body
}
```
self가 취할 수 있는 세 가지 주요 형태는 `self`, `&self`, `&self`입니다. 이 세 가지 형태는 Rust에서 소유권의 세 가지 기본 형태를 나타냅니다:

* `self` - 값
* `&mut self` - 가변 참조자
* `&self` - 공유 참조자

값은 *진정한* 소유권을 나타냅니다. 값으로 이동, 파괴, 변경, 참조를 통한 대여 등 원하는 것은 무엇이든 할 수 있습니다. 값으로 무언가를 전달하면 새 위치로 *이동*됩니다. 이제 새 위치가 값을 소유하게 되고 이전 위치는 더 이상 값에 액세스할 수 없습니다. 이런 이유로 대부분의 메서드는 `self`를 원하지 않습니다. 리스트로 작업하려다 사라진다면 꽤나 구식일 것입니다!

가변 참조자는 소유하지 않은 값에 대한 일시적인 *독점적 액세스*를 나타냅니다. 가변 참조자가 있는 값에 대해 작업을 마쳤을 때 유효한 상태로 두기만 하면 원하는 모든 작업을 할 수 있습니다(그렇지 않으면 소유자에게 실례가 되겠죠!). 즉, 실제로 값을 완전히 덮어쓸 수 있습니다. 정말 유용한 특수한 경우는 값을 다른 값으로 *바꾸는* 것인데, 앞으로 많이 사용하게 될 것입니다. `&mut`으로 할 수 없는 유일한 일은 대체하지 않고 값을 옮기는 것입니다. `&mut self`는 `self`을 변이하려는 메서드에 유용합니다.

공유 참조자는 소유하지 않은 값에 대한 일시적인 *공유 액세스*를 나타냅니다. 공유 액세스 권한이 있기 때문에 일반적으로 아무것도 변경할 수 없습니다. `&`는 박물관에 가치를 전시하는 것과 같다고 생각하면 됩니다. `&`는 `self`만을 관찰하려는 메서드에 적합합니다.

나중에 특정 경우 변경에 대한 규칙을 우회할 수 있다는 것을 알게 될 것입니다. 이것이 바로 공유 참조를 *불변* 참조라고 부르지 않는 이유입니다. 실제로 가변 참조자는 *유일한* 참조라고 할 수 있지만, 소유권과 가변성을 연관시키는 것이 99%의 경우 올바른 직관을 제공한다는 사실을 발견했습니다.
